4806   //            JMP readEl         ; call subroutine
4821   //            JMP display        ; call subroutine
483D   //            JMP MinMax         ; call subroutine
0000   //            HLT                ; end of program
0000   //            padding
0000   //            padding
2402   // readEl     INP X              ; read N(number of elements) into register X
B0B2   //            MOV Y, #50         ; adress of i(contor)
B000   //            MOV AC, #0         ; initialize i = 0
1200   //            STR AC, 0(Y)       ; store the value into memory
B0B3   //            MOV Y, #51         ; address of the address of the array
B020   //            MOV AC, #32        ; AC = 32
9C02   //            LSL AC, #2         ; AC = 32 << 2 = 128
1200   //            STR AC, 0(Y)       ; store the value into memory
B0B2   // loop       MOV Y, #50         ; address of i
0A00   //            LDR AC, 0(Y)       ; load i
A801   //            CMP AC, X          ; compare i < N
3C1E   //            BGE endloop        ; branch if i == N
2401   //            INP AC             ; read element
07F3   //            LDR Y, #51         ; load address of the array
1200   //            STR AC, 0(Y)       ; store v[i]
B0B2   //            MOV Y, #50         ; address of i
0A00   //            LDR AC, 0(Y)       ; load i
5101   //            ADD AC, #1         ; increment i
1200   //            STR AC, 0(Y)       ; store i
B0B3   //            MOV Y, #51         ; address of the address of the array
0A00   //            LDR AC, 0(Y)       ; load address
5101   //            ADD AC, #1         ; increment address
1200   //            STR AC, 0(Y)       ; store address
440E   //            BRA loop           ; next iteration
4C00   // endloop    RET                
0000   //            padding     
0000   //            padding     
2402   // display    INP X              ; read N(number of elements) into register X
B0B2   //            MOV Y, #50         ; adress of i(contor)
B000   //            MOV #0             ; initialize i = 0
1200   //            STR AC, 0(Y)       ; store the value into memory
B0B3   //            MOV Y, #51         ; address of the address of the array
B020   //            MOV AC, #32        ; AC = 32
9C02   //            LSL AC, #2         ; AC = 32 << 2 = 128
1200   //            STR AC, 0(Y)       ; store the value into memory
B0B2   // loop       MOV Y, #50         ; address of i
0A00   //            LDR AC, 0(Y)       ; load i
A801   //            CMP AC, X          ; compare i < N
3C39   //            BGE endloop        ; branch if i == N
07F3   //            LDR Y, #51         ; load address of the array
0A00   //            LDR AC, 0(Y)       ; load v[i]
2801   //            OUT AC             ; print element to output
B0B2   //            MOV Y, #50         ; address of i
0A00   //            LDR AC, 0(Y)       ; load i
5101   //            ADD AC, #1         ; increment i
1200   //            STR AC, 0(Y)       ; store i
B0B3   //            MOV Y, #51         ; address of the address of the array
0A00   //            LDR AC, 0(Y)       ; load address
5101   //            ADD AC, #1         ; increment address
1200   //            STR AC, 0(Y)       ; store address
4429   //            BRA loop           ; next iteration
4C00   // endloop    RET                ; end of subroutine
0000   //            padding
0000   //            padding
0000   //            padding
B0B1   // MinMax     MOV Y, #49         ; address of N(number of elements)
2401   //            INP AC             ; read N
1200   //            STR AC, 0(Y)       ; store N in memory
B0B2   //            MOV Y, #50         ; address of i(contor)
B000   //            MOV AC, #0         ; initialize i = 0
1200   //            STR AC, 0(Y)       ; store i into memory
B0B3   //            MOV Y, #51         ; address of the address of the array  
B020   //            MOV AC, #32        ; AC = 32
9C02   //            LSL AC, #2         ; AC = 32 << 2 = 128 (array addres)
1200   //            STR AC, 0(Y)       ; store the address into memory
B440   //            MOV Y, AC          ; Y = address of array
0A00   //            LDR AC, 0(Y)       ; load v[0]
B0B4   //            MOV Y, #52         ; Y = address of min
1200   //            STR AC, 0(Y)       ; min value from Mem[#52]
1201   //            STR AC, 1(Y)       ; max value from Mem[#53]
B0B1   //            MOV Y, #49         ; Y = address of N
0A00   // loop       LDR AC, 0(Y)       ; load N
B420   //            MOV X, AC          ; X = N
0A01   //            LDR AC, 1(Y)       ; load i
A801   //            CMP AC, X          ; compare i < N
3C67   //            BGE endloop        ; if i == N, go to endloop
0A02   //            LDR AC, 2(Y)       ; load address of the array
B420   //            MOV X, AC          ; X = address of the array
0800   //            LDR AC, 0(X)       ; load v[i]
B420   //            MOV X, AC          ; X = v[i]         
0A03   //            LDR AC, 3(Y)       ; load min
A801   // if         CMP AC, X          ; compare min and v[i]
405B   //            BLE if2            ; branch if min < v[i]
B401   //            MOV AC, X          ; if v[i] < min, then min = v[i]
1203   //            STR AC, 3(Y)       ; store new value of min into memory
0A04   //   if2      LDR AC, 4(Y)       ; load max
A801   //            CMP AC, X          ; compare max and v[i]
3C60   //            BGE endif          ; branch if max > v[i]
B401   //            MOV AC, X          ; if v[i] > max, then max = v[i]
1204   //            STR AC, 4(Y)       ; store new value of max into memory
0A01   // endif      LDR AC, 1(Y)       ; load i
5101   //            ADD AC, #1         ; increment i
1201   //            STR AC, 1(Y)       ; store new value of i into memory
0A02   //            LDR AC, 2(Y)       ; load address
5101   //            ADD AC, #1         ; increment address for v[i+1]
1202   //            STR AC, 2(Y)       ; store new value into memory
444D   //            BRA loop           ; next iteration
0A03   // endloop    LDR AC, 3(Y)       ; load min
2801   //            OUT AC             ; print min to output
0A04   //            LDR AC, 4(Y)       ; load max
2801   //            OUT AC             ; print max to output
4C00   //            RET                ; end of subroutine
            

            