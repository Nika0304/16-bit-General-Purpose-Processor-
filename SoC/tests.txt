/// 1. First Program
0407 // 0000 0100 0000 0110 (X = Mem(address))
0A08 // 0000 1010 0000 0111  (ACC = Mem(Y + offset)) Y=0 
1409 // 0001 0100 0000 1000   (ACC = Mem(address))
0C0A // 0000 1100 0000 1001 (Mem(address) = X)
120B // 0001 0010 0000 1010  (Mem(Y + offset) = ACC)
180C // 0001 1000 0000 1011   (Mem(address) = ACC)


/// 2. Second Program
040A // 0000 0100 0000 0110  X = Mem(address)
0A0B // 0000 1010 0000 0111  ACC = Mem(Y + offset) Y=0 
140C // 0001 0100 0000 1000  ACC = Mem(address)
0C0D // 0000 1100 0000 1001  Mem(address) = X
120E // 0001 0010 0000 1010  Mem(Y + offset) = ACC
060F // 0000 0110 0000 0110  Y = Mem(address)
1810 // 0001 1000 0000 1011  Mem(address) = ACC
0411 // 0000 0100 0000 0110  X = Mem(address)
0412 // 0000 0100 0000 0110  Y = Mem(address)
0C0D // 0000 1110 0000 1001  Mem(address) = Y
0000
1234
1235
1236
1237
1238
1239
1240
1241
1242
1243

/// 3. Memory Program 
// =========================================================================
// TEST PROGRAM - PUSH, POP, INP, OUT + instructiuni de baza
// =========================================================================
// SP initial = 0x01FF (stack creste in jos)
// Format PUSH/POP/INP/OUT: opcode[15:10], imm[9:0]
// imm[9:4] = 000000, imm[3:0] = reg_code (0=PC, 1=AC, 2=X, 3=Y)
// =========================================================================

// --- SECTIUNEA 1: Incarca valori initiale ---
0430 // 0x00: LDR X, #30      -> X = Mem[30] = 0002
0631 // 0x01: LDR Y, #31      -> Y = Mem[31] = 0003
1432 // 0x02: LDA AC, #32     -> AC = Mem[32] = 1234

// --- SECTIUNEA 2: Test PUSH ---
1C01 // 0x03: PUSH AC         -> Mem[SP] = AC = 1234, SP--  (SP: 1FF->1FE)
1C02 // 0x04: PUSH X          -> Mem[SP] = X = 0002, SP--   (SP: 1FE->1FD)
1C03 // 0x05: PUSH Y          -> Mem[SP] = Y = 0003, SP--   (SP: 1FD->1FC)

// --- SECTIUNEA 3: Schimba valorile registrelor ---
0433 // 0x06: LDR X, #33      -> X = Mem[33] = AAAA (valoare noua)
0634 // 0x07: LDR Y, #34      -> Y = Mem[34] = BBBB (valoare noua)
1435 // 0x08: LDA AC, #35     -> AC = Mem[35] = CCCC (valoare noua)

// --- SECTIUNEA 4: Test POP (ordine inversa) ---
2003 // 0x09: POP Y           -> SP++, Y = Mem[SP] = 0003   (SP: 1FC->1FD)
2002 // 0x0A: POP X           -> SP++, X = Mem[SP] = 0002   (SP: 1FD->1FE)
2001 // 0x0B: POP AC          -> SP++, AC = Mem[SP] = 1234  (SP: 1FE->1FF)

// --- SECTIUNEA 5: Store pentru verificare POP ---
0C36 // 0x0C: STR X, #36      -> Mem[36] = X = 0002
0E37 // 0x0D: STR Y, #37      -> Mem[37] = Y = 0003
1838 // 0x0E: STA #38         -> Mem[38] = AC = 1234

// --- SECTIUNEA 6: Test INP/OUT ---
2401 // 0x0F: INP AC          -> AC = input de la tastatura
1839 // 0x10: STA #39         -> Mem[39] = AC (valoare citita)
2402 // 0x11: INP X           -> X = input de la tastatura
0C3A // 0x12: STR X, #3A      -> Mem[3A] = X (valoare citita)
2801 // 0x13: OUT AC          -> Afiseaza AC
2802 // 0x14: OUT X           -> Afiseaza X

// --- SECTIUNEA 7: HLT ---
0000 // 0x15: HLT             -> Stop

// --- PADDING ---
0000 // 0x16
0000 // 0x17
0000 // 0x18
0000 // 0x19
0000 // 0x1A
0000 // 0x1B
0000 // 0x1C
0000 // 0x1D
0000 // 0x1E
0000 // 0x1F
0000 // 0x20
0000 // 0x21
0000 // 0x22
0000 // 0x23
0000 // 0x24
0000 // 0x25
0000 // 0x26
0000 // 0x27
0000 // 0x28
0000 // 0x29
0000 // 0x2A
0000 // 0x2B
0000 // 0x2C
0000 // 0x2D
0000 // 0x2E
0000 // 0x2F

// --- DATA SECTION (0x30-0x3F) ---
0002 // 0x30: valoare initiala X
0003 // 0x31: valoare initiala Y
1234 // 0x32: valoare initiala AC
AAAA // 0x33: valoare noua X (dupa PUSH, inainte POP)
BBBB // 0x34: valoare noua Y (dupa PUSH, inainte POP)
CCCC // 0x35: valoare noua AC (dupa PUSH, inainte POP)
0000 // 0x36: pentru verificare X dupa POP
0000 // 0x37: pentru verificare Y dupa POP
0000 // 0x38: pentru verificare AC dupa POP
0000 // 0x39: pentru valoare INP AC
0000 // 0x3A: pentru valoare INP X

/// 4. Memory + Branch Instructions Program
// =========================================================================
// TEST PROGRAM - Toate instructiunile implementate
// =========================================================================
// SP initial = 0x200 (512), stack creste in jos
// Memoria: 512 adrese (9 biti), adrese 0x000 - 0x1FF
// =========================================================================

// ==========================================================================
// SECTIUNEA 1: Test LDR, LDA_IMM, STR, STA_IMM (instructiuni de baza)
// ==========================================================================
0430    // 0x00: LDR X, #30         -> X = Mem[0x30] = 0x000A (10)
0631    // 0x01: LDR Y, #31         -> Y = Mem[0x31] = 0x0014 (20)
1432    // 0x02: LDA_IMM #32        -> AC = Mem[0x32] = 0x001E (30)

// ==========================================================================
// SECTIUNEA 2: Test PUSH/POP
// ==========================================================================
1C01    // 0x03: PUSH AC            -> Mem[0x1FF] = AC = 0x001E, SP = 0x1FE
1C02    // 0x04: PUSH X             -> Mem[0x1FE] = X = 0x000A, SP = 0x1FD
1C03    // 0x05: PUSH Y             -> Mem[0x1FD] = Y = 0x0014, SP = 0x1FC

0433    // 0x06: LDR X, #33         -> X = Mem[0x33] = 0xAAAA (schimba valori)
0634    // 0x07: LDR Y, #34         -> Y = Mem[0x34] = 0xBBBB
1435    // 0x08: LDA_IMM #35        -> AC = Mem[0x35] = 0xCCCC

2003    // 0x09: POP Y              -> SP = 0x1FD, Y = Mem[0x1FD] = 0x0014
2002    // 0x0A: POP X              -> SP = 0x1FE, X = Mem[0x1FE] = 0x000A
2001    // 0x0B: POP AC             -> SP = 0x1FF, AC = Mem[0x1FF] = 0x001E

// Store rezultate POP pentru verificare
0C40    // 0x0C: STR X, #40         -> Mem[0x40] = X = 0x000A
0E41    // 0x0D: STR Y, #41         -> Mem[0x41] = Y = 0x0014
1842    // 0x0E: STA_IMM #42        -> Mem[0x42] = AC = 0x001E

// ==========================================================================
// SECTIUNEA 3: Test JMP si RET
// ==========================================================================
// JMP salveaza PC+1 pe stack si sare la adresa
// RET restaureaza PC de pe stack

4820    // 0x0F: JMP 0x20           -> PUSH PC+1 (0x10), PC = 0x20 (subroutine)
        // Dupa RET, executia continua de la 0x10

// Dupa return din subroutine:
0C43    // 0x10: STR X, #43         -> Mem[0x43] = X = 0x0055 (setat in subroutine)
0E44    // 0x11: STR Y, #44         -> Mem[0x44] = Y = 0x00AA (setat in subroutine)

// ==========================================================================
// SECTIUNEA 4: Test BRA (branch always)
// ==========================================================================
4415    // 0x12: BRA 0x15           -> PC = 0x15 (sare peste 0x13, 0x14)

// Aceste instructiuni NU ar trebui executate (sarite de BRA)
0436    // 0x13: LDR X, #36         -> X = 0xDEAD (NU se executa)
0637    // 0x14: LDR Y, #37         -> Y = 0xBEEF (NU se executa)

// Continuare dupa BRA
1845    // 0x15: STA_IMM #45        -> Mem[0x45] = AC = 0x001E (verifica BRA a sarit)

// ==========================================================================
// SECTIUNEA 5: Test Conditional Branches (BNE, BEQ, etc.)
// ==========================================================================
// Nota: Flag-urile sunt probabil 0 dupa reset (Z=0, N=0, V=0, C=0)
// BNE (Z=0) ar trebui sa fie TAKEN
// BEQ (Z=1) ar trebui sa fie NOT TAKEN

3019    // 0x16: BNE 0x19           -> Z=0, deci branch TAKEN, PC = 0x19

// Aceste instructiuni NU ar trebui executate (sarite de BNE)
0436    // 0x17: LDR X, #36         -> X = 0xDEAD (NU se executa)
0637    // 0x18: LDR Y, #37         -> Y = 0xBEEF (NU se executa)

// Continuare dupa BNE
1846    // 0x19: STA_IMM #46        -> Mem[0x46] = AC (verifica BNE a sarit)

// Test BEQ - ar trebui sa NU fie luat (Z=0)
2C1C    // 0x1A: BEQ 0x1C           -> Z=0, deci branch NOT TAKEN, continua la 0x1B

1847    // 0x1B: STA_IMM #47        -> Mem[0x47] = AC (verifica BEQ NU a sarit)

// ==========================================================================
// SECTIUNEA 6: HLT
// ==========================================================================
0000    // 0x1C: HLT                -> Stop

// ==========================================================================
// PADDING (0x1D - 0x1F)
// ==========================================================================
0000    // 0x1D
0000    // 0x1E
0000    // 0x1F

// ==========================================================================
// SUBROUTINE la adresa 0x20 (apelata de JMP)
// ==========================================================================
0438    // 0x20: LDR X, #38         -> X = Mem[0x38] = 0x0055
0639    // 0x21: LDR Y, #39         -> Y = Mem[0x39] = 0x00AA
4C00    // 0x22: RET                -> POP PC, revine la 0x10

// ==========================================================================
// PADDING (0x23 - 0x2F)
// ==========================================================================
0000    // 0x23
0000    // 0x24
0000    // 0x25
0000    // 0x26
0000    // 0x27
0000    // 0x28
0000    // 0x29
0000    // 0x2A
0000    // 0x2B
0000    // 0x2C
0000    // 0x2D
0000    // 0x2E
0000    // 0x2F

// ==========================================================================
// DATA SECTION (0x30 - 0x4F)
// ==========================================================================
000A    // 0x30: valoare initiala X = 10
0014    // 0x31: valoare initiala Y = 20
001E    // 0x32: valoare initiala AC = 30
AAAA    // 0x33: valoare temporara X
BBBB    // 0x34: valoare temporara Y
CCCC    // 0x35: valoare temporara AC
DEAD    // 0x36: valoare "bad" X (nu ar trebui citita)
BEEF    // 0x37: valoare "bad" Y (nu ar trebui citita)
0055    // 0x38: valoare subroutine X
00AA    // 0x39: valoare subroutine Y
0000    // 0x3A
0000    // 0x3B
0000    // 0x3C
0000    // 0x3D
0000    // 0x3E
0000    // 0x3F

// Zona pentru rezultate verificare (0x40 - 0x4F)
0000    // 0x40: rezultat POP X
0000    // 0x41: rezultat POP Y
0000    // 0x42: rezultat POP AC
0000    // 0x43: rezultat subroutine X
0000    // 0x44: rezultat subroutine Y
0000    // 0x45: marker BRA executat
0000    // 0x46: marker BNE executat
0000    // 0x47: marker BEQ NOT taken


/// 4
// =========================================================================
// COMPREHENSIVE TEST PROGRAM - ALL INSTRUCTIONS
// =========================================================================
// SP initial = 0x200 (512), memoria: 512 adrese (9 biti)
// =========================================================================

// ==========================================================================
// SECTIUNEA 1: Test MOV (Load initial values using MOV)
// ==========================================================================
B44A    // 0x00: MOV X, #10         -> X = 10 (0x000A)
B494    // 0x01: MOV Y, #20         -> Y = 20 (0x0014)
B41E    // 0x02: MOV AC, #30        -> AC = 30 (0x001E)
0C50    // 0x03: STR X, #50         -> Mem[50] = X = 0x000A
0E51    // 0x04: STR Y, #51         -> Mem[51] = Y = 0x0014
1852    // 0x05: STA #52            -> Mem[52] = AC = 0x001E

// ==========================================================================
// SECTIUNEA 2: Test ARITHMETIC (Reg) - ADD, SUB, MUL, DIV, MOD
// ==========================================================================
// AC = 30 (0x1E), X = 10, Y = 20

5000    // 0x06: ADD AC, X          -> AC = AC + X = 30 + 10 = 40 (0x28)
1853    // 0x07: STA #53            -> Mem[53] = 40

5500    // 0x08: SUB AC, X          -> AC = AC - X = 40 - 10 = 30 (0x1E)
1854    // 0x09: STA #54            -> Mem[54] = 30

5105    // 0x0A: ADD AC, #5         -> AC = AC + 5 = 30 + 5 = 35 (0x23)
1855    // 0x0B: STA #55            -> Mem[55] = 35

5902    // 0x0C: SUB AC, #2         -> AC = AC - 2 = 35 - 2 = 33 (0x21)
1856    // 0x0D: STA #56            -> Mem[56] = 33

B403    // 0x0E: MOV AC, #3         -> AC = 3
5A00    // 0x0F: MUL AC, X          -> AC = AC * X = 3 * 10 = 30 (0x1E)
1857    // 0x10: STA #57            -> Mem[57] = 30

B428    // 0x11: MOV AC, #40        -> AC = 40
5E00    // 0x12: DIV AC, X          -> AC = AC / X = 40 / 10 = 4
1858    // 0x13: STA #58            -> Mem[58] = 4

B417    // 0x14: MOV AC, #23        -> AC = 23
6200    // 0x15: MOD AC, X          -> AC = AC % X = 23 % 10 = 3
1859    // 0x16: STA #59            -> Mem[59] = 3

// ==========================================================================
// SECTIUNEA 3: Test LOGIC (Reg) - AND, OR, XOR, NOT
// ==========================================================================
B40F    // 0x17: MOV AC, #15        -> AC = 0x0F (00001111)
B407    // 0x18: MOV X, #7          -> X = 0x07 (00000111)

6600    // 0x19: AND AC, X          -> AC = AC & X = 0x0F & 0x07 = 0x07
185A    // 0x1A: STA #5A            -> Mem[5A] = 0x07

B40F    // 0x1B: MOV AC, #15        -> AC = 0x0F
6A00    // 0x1C: OR AC, X           -> AC = AC | X = 0x0F | 0x07 = 0x0F
185B    // 0x1D: STA #5B            -> Mem[5B] = 0x0F

B408    // 0x1E: MOV AC, #8         -> AC = 0x08
6E00    // 0x1F: XOR AC, X          -> AC = AC ^ X = 0x08 ^ 0x07 = 0x0F
185C    // 0x20: STA #5C            -> Mem[5C] = 0x0F

7000    // 0x21: NOT X              -> AC = ~X = ~0x07 = 0xFFF8
185D    // 0x22: STA #5D            -> Mem[5D] = 0xFFF8

// ==========================================================================
// SECTIUNEA 4: Test ARITHMETIC (Memory) - ADD_M, SUB_M
// ==========================================================================
B40A    // 0x23: MOV AC, #10        -> AC = 10
7460    // 0x24: ADD_M #60          -> AC = AC + Mem[60] = 10 + 5 = 15
185E    // 0x25: STA #5E            -> Mem[5E] = 15

B414    // 0x26: MOV AC, #20        -> AC = 20
7860    // 0x27: SUB_M #60          -> AC = AC - Mem[60] = 20 - 5 = 15
185F    // 0x28: STA #5F            -> Mem[5F] = 15

// ==========================================================================
// SECTIUNEA 5: Test SHIFTS - LSR, LSL, RSR, RSL
// ==========================================================================
B410    // 0x29: MOV AC, #16        -> AC = 16 (0x10)
9801    // 0x2A: LSR #1             -> AC = AC >> 1 = 16 >> 1 = 8
1860    // 0x2B: STA #60            -> Mem[60] = 8 (overwrite old value)

B404    // 0x2C: MOV AC, #4         -> AC = 4
9C02    // 0x2D: LSL #2             -> AC = AC << 2 = 4 << 2 = 16
1861    // 0x2E: STA #61            -> Mem[61] = 16

B4A0    // 0x2F: MOV AC, #160       -> AC = 0x00A0 (10100000)
A000    // 0x30: RSR                -> AC rotate right 1 = 0x0050 (01010000)
1862    // 0x31: STA #62            -> Mem[62] = 0x50

B405    // 0x32: MOV AC, #5         -> AC = 0x0005 (00000101)
A400    // 0x33: RSL                -> AC rotate left 1 = 0x000A (00001010)
1863    // 0x34: STA #63            -> Mem[63] = 0x0A

// ==========================================================================
// SECTIUNEA 6: Test CMP/TST and conditional branches
// ==========================================================================
B40A    // 0x35: MOV AC, #10        -> AC = 10
B40A    // 0x36: MOV X, #10         -> X = 10
A801    // 0x37: CMP AC, X          -> AC - X = 0, Z=1

2C3A    // 0x38: BEQ 0x3A           -> Z=1, TAKEN -> PC = 0x3A
0464    // 0x39: LDR X, #64         -> NU se executa (skip)

// Continuare dupa BEQ (0x3A)
B401    // 0x3A: MOV AC, #1         -> AC = 1 (marker BEQ taken)
1864    // 0x3B: STA #64            -> Mem[64] = 1

B40F    // 0x3C: MOV AC, #15        -> AC = 15
B405    // 0x3D: MOV X, #5          -> X = 5
A801    // 0x3E: CMP AC, X          -> AC - X = 10 > 0, Z=0, N=0, V=0 (N==V)

3440    // 0x3F: BGT 0x40           -> BGT TAKEN -> PC = 0x40

// Continuare dupa BGT (0x40)
B402    // 0x40: MOV AC, #2         -> AC = 2 (marker BGT taken)
1865    // 0x41: STA #65            -> Mem[65] = 2

// ==========================================================================
// SECTIUNEA 7: Test MOV Reg, Reg
// ==========================================================================
B40A    // 0x43: MOV AC, #10        -> AC = 10
B020    // 0x44: MOV X, AC          -> X = AC = 10
B041    // 0x45: MOV Y, X           -> Y = X = 10
0E66    // 0x46: STR Y, #66         -> Mem[66] = Y = 10

// ==========================================================================
// SECTIUNEA 8: Test JMP/RET (verify stack operations work with ALU)
// ==========================================================================
486E    // 0x47: JMP 0x6E           -> PUSH PC+1 (0x48), jump to subroutine

// Return point after subroutine
0C67    // 0x48: STR X, #67         -> Mem[67] = X (set in subroutine)
0E68    // 0x49: STR Y, #68         -> Mem[68] = Y (set in subroutine)

// ==========================================================================
// SECTIUNEA 9: HLT
// ==========================================================================
0000    // 0x4A: HLT                -> Stop

// ==========================================================================
// PADDING (0x4B - 0x4F)
// ==========================================================================
0000    // 0x4B
0000    // 0x4C
0000    // 0x4D
0000    // 0x4E
0000    // 0x4F

// ==========================================================================
// DATA SECTION (0x50 - 0x6F)
// ==========================================================================
0000    // 0x50: space for STR X result
0000    // 0x51: space for STR Y result
0000    // 0x52: space for STA AC result
0000    // 0x53: ADD AC, X result = 40
0000    // 0x54: SUB AC, X result = 30
0000    // 0x55: ADD AC, #5 result = 35
0000    // 0x56: SUB AC, #2 result = 33
0000    // 0x57: MUL AC, X result = 30
0000    // 0x58: DIV AC, X result = 4
0000    // 0x59: MOD AC, X result = 3
0000    // 0x5A: AND AC, X result = 7
0000    // 0x5B: OR AC, X result = 15
0000    // 0x5C: XOR AC, X result = 15
0000    // 0x5D: NOT X result = 0xFFF8
0000    // 0x5E: ADD_M result = 15
0000    // 0x5F: SUB_M result = 15
0005    // 0x60: data for memory operations (5, overwritten by LSR = 8)
0000    // 0x61: LSL result = 16
0000    // 0x62: RSR result = 0x50
0000    // 0x63: RSL result = 0x0A
0000    // 0x64: BEQ marker = 1
0000    // 0x65: BGT marker = 2
0000    // 0x66: MOV Y,X result = 10
0000    // 0x67: subroutine X result
0000    // 0x68: subroutine Y result
0000    // 0x69
0000    // 0x6A
0000    // 0x6B
0000    // 0x6C
0000    // 0x6D

// ==========================================================================
// SUBROUTINE at 0x6E (called by JMP)
// ==========================================================================
B432    // 0x6E: MOV X, #50         -> X = 50 (0x32)
B464    // 0x6F: MOV Y, #100        -> Y = 100 (0x64)
4C00    // 0x70: RET                -> POP PC, return to 0x48

/// 5
// =========================================================================
// TEST PROGRAM - Arithmetic, Logic, MOV, CMP (Opcodes 010100+)
// =========================================================================
// Testeaza doar instructiunile noi: ADD, SUB, MUL, DIV, MOD, AND, OR, XOR,
// NOT, shifts, CMP, TST, MOV
// Folosim LDA/STA pentru load/store (stim ca functioneaza)
// =========================================================================

// ==========================================================================
// SECTIUNEA 1: Test MOV Reg, #Imm (opcode 101101)
// ==========================================================================
B00A    // 0x00: MOV AC, #10        -> AC = 10 (0x000A)
1850    // 0x01: STA #50            -> Mem[50] = AC = 0x000A

B054    // 0x02: MOV X, #20         -> X = 20 (0x0014)
0C51    // 0x03: STR X, #51         -> Mem[51] = X = 0xFFF4

B09E    // 0x04: MOV Y, #30         -> Y = 30 (0x001E)
0E52    // 0x05: STR Y, #52         -> Mem[52] = Y = 0x001E

// ==========================================================================
// SECTIUNEA 2: Test MOV Reg, Reg (opcode 101100)
// ==========================================================================
B00F    // 0x06: MOV AC, #15        -> AC = 15
B420    // 0x07: MOV X, AC          -> X = AC = 15
0C53    // 0x08: STR X, #53         -> Mem[53] = X = 15

B441    // 0x09: MOV Y, X           -> Y = X = 15
0E54    // 0x0A: STR Y, #54         -> Mem[54] = Y = 15

// ==========================================================================
// SECTIUNEA 3: Test ADD/SUB (Reg) - opcode 010100, 010101
// ==========================================================================
B00A    // 0x0B: MOV AC, #10        -> AC = 10
B045    // 0x0C: MOV X, #5          -> X = 5

5000    // 0x0D: ADD AC, X          -> AC = AC + X = 10 + 5 = 15
1855    // 0x0E: STA #55            -> Mem[55] = 15

5400    // 0x0F: SUB AC, X          -> AC = AC - X = 15 - 5 = 10
1856    // 0x10: STA #56            -> Mem[56] = 10

// ==========================================================================
// SECTIUNEA 4: Test ADD/SUB (Imm) - M=1
// ==========================================================================
B00A    // 0x11: MOV AC, #10        -> AC = 10
5107    // 0x12: ADD AC, #7         -> AC = AC + 7 = 10 + 7 = 17
1857    // 0x13: STA #57            -> Mem[57] = 17

5503    // 0x14: SUB AC, #3         -> AC = AC - 3 = 17 - 3 = 14
1858    // 0x15: STA #58            -> Mem[58] = 14

// ==========================================================================
// SECTIUNEA 5: Test MUL/DIV/MOD - opcode 010110, 010111, 011000
// ==========================================================================
B005    // 0x16: MOV AC, #5         -> AC = 5
B043    // 0x17: MOV X, #3          -> X = 3

5800    // 0x18: MUL AC, X          -> AC = AC * X = 5 * 3 = 15
1859    // 0x19: STA #59            -> Mem[59] = 15

B014    // 0x1A: MOV AC, #20        -> AC = 20
5C00    // 0x1B: DIV AC, X          -> AC = AC / X = 20 / 3 = 6
185A    // 0x1C: STA #5A            -> Mem[5A] = 6

6000    // 0x1D: MOD AC, X          -> AC = AC % X = 6 % 3 = 0
185B    // 0x1E: STA #5B            -> Mem[5B] = 0

// ==========================================================================
// SECTIUNEA 6: Test AND/OR/XOR - opcode 011001, 011010, 011011
// ==========================================================================
B00F    // 0x1F: MOV AC, #15        -> AC = 0x0F (00001111)
B047    // 0x20: MOV X, #7          -> X = 0x07 (00000111)

6400    // 0x21: AND AC, X          -> AC = AC & X = 0x0F & 0x07 = 0x07
185C    // 0x22: STA #5C            -> Mem[5C] = 0x07

B00F    // 0x23: MOV AC, #15        -> AC = 0x0F
6800    // 0x24: OR AC, X           -> AC = AC | X = 0x0F | 0x07 = 0x0F
185D    // 0x25: STA #5D            -> Mem[5D] = 0x0F

B008    // 0x26: MOV AC, #8         -> AC = 0x08
6C00    // 0x27: XOR AC, X          -> AC = AC ^ X = 0x08 ^ 0x07 = 0x0F
185E    // 0x28: STA #5E            -> Mem[5E] = 0x0F

// ==========================================================================
// SECTIUNEA 7: Test NOT - opcode 011100
// ==========================================================================
B047    // 0x29: MOV X, #7          -> X = 0x07
7000    // 0x2A: NOT X              -> AC = ~X = ~0x07 = 0xFFF8
185F    // 0x2B: STA #5F            -> Mem[5F] = 0xFFF8

// ==========================================================================
// SECTIUNEA 8: Test LSR/LSL - opcode 100110, 100111
// ==========================================================================
B010    // 0x2C: MOV AC, #16        -> AC = 16 (0x10)
9801    // 0x2D: LSR #1             -> AC = AC >> 1 = 16 >> 1 = 8
1860    // 0x2E: STA #60            -> Mem[60] = 8

B004    // 0x2F: MOV AC, #4         -> AC = 4
9C02    // 0x30: LSL #2             -> AC = AC << 2 = 4 << 2 = 16
1861    // 0x31: STA #61            -> Mem[61] = 16

// ==========================================================================
// SECTIUNEA 9: Test RSR/RSL - opcode 101000, 101001
// ==========================================================================
B030    // 0x32: MOV AC, #30       -> AC = 0xFFF0 (110000)
A001    // 0x33: RSR #1             -> AC rotate right = 0x7FF8
1862    // 0x34: STA #62            -> Mem[62] = 0x7FF8

B005    // 0x35: MOV AC, #5         -> AC = 0x0005 (00000101)
A402    // 0x36: RSL #2             -> AC rotate left = 0x0014
1863    // 0x37: STA #63            -> Mem[63] = 0x0A

// ==========================================================================
// SECTIUNEA 10: Test CMP - opcode 101010
// ==========================================================================
B00A    // 0x38: MOV AC, #10        -> AC = 10
B04A    // 0x39: MOV X, #10         -> X = 10
A801    // 0x3A: CMP AC, X          -> AC - X = 0, Z=1

2C3D    // 0x3B: BEQ 0x3D           -> Z=1, taken
B03F    // 0x3C: MOV AC, #3F       -> skip (not executed)

B001    // 0x3D: MOV AC, #1         -> AC = 1 (marker CMP==)
1864    // 0x3E: STA #64            -> Mem[64] = 1

// ==========================================================================
// SECTIUNEA 11: Test TST - opcode 101011
// ==========================================================================
B00F    // 0x3F: MOV AC, #15        -> AC = 0x0F
B047    // 0x40: MOV X, #7          -> X = 0x07
AC01    // 0x41: TST AC, X          -> AC & X = 0x07, Z=0

3044    // 0x42: BNE 0x44           -> Z=0, taken
B03F    // 0x43: MOV AC, #3F      -> skip (not executed)

B002    // 0x44: MOV AC, #2         -> AC = 2 (marker TST!=0)
1865    // 0x45: STA #65            -> Mem[65] = 2

// ==========================================================================
// SECTIUNEA 12: HLT
// ==========================================================================
0000    // 0x46: HLT                -> Stop

// ==========================================================================
// PADDING
// ==========================================================================
0000    // 0x47
0000    // 0x48
0000    // 0x49
0000    // 0x4A
0000    // 0x4B
0000    // 0x4C
0000    // 0x4D
0000    // 0x4E
0000    // 0x4F

// ==========================================================================
// DATA SECTION (0x50 - 0x65)
// ==========================================================================
0000    // 0x50: MOV AC, #10 result
0000    // 0x51: MOV X, #20 result
0000    // 0x52: MOV Y, #30 result
0000    // 0x53: MOV X, AC result = 15
0000    // 0x54: MOV Y, X result = 15
0000    // 0x55: ADD AC, X result = 15
0000    // 0x56: SUB AC, X result = 10
0000    // 0x57: ADD AC, #7 result = 17
0000    // 0x58: SUB AC, #3 result = 14
0000    // 0x59: MUL AC, X result = 15
0000    // 0x5A: DIV AC, X result = 6
0000    // 0x5B: MOD AC, X result = 0
0000    // 0x5C: AND AC, X result = 7
0000    // 0x5D: OR AC, X result = 15
0000    // 0x5E: XOR AC, X result = 15
0000    // 0x5F: NOT X result = 0xFFF8
0000    // 0x60: LSR result = 8
0000    // 0x61: LSL result = 16
0000    // 0x62: RSR result = 0x50
0000    // 0x63: RSL result = 0x0A
0000    // 0x64: CMP marker = 1
0000    // 0x65: TST marker = 2


///6

// =========================================================================
// COMPREHENSIVE TEST PROGRAM - ALL INSTRUCTIONS
// =========================================================================
// Tests ALL instructions from instructions_format.txt
// Priority: ALU Memory operations first, then all others
// Memory layout:
//   0x00-0x7F: Program code
//   0x80-0x8F: Test data for ALU memory operations
//   0x90-0xCF: Test results
// =========================================================================

// ==========================================================================
// SECTION 1: Initialize test data in memory for ALU Memory operations
// ==========================================================================
B00A    // 0x00: MOV AC, #10        -> AC = 10
1900    // 0x01: STA #80            -> Mem[0x80] = 10

B005    // 0x02: MOV AC, #5         -> AC = 5
1901    // 0x03: STA #81            -> Mem[0x81] = 5

B014    // 0x04: MOV AC, #20        -> AC = 20
1902    // 0x05: STA #82            -> Mem[0x82] = 20

B003    // 0x06: MOV AC, #3         -> AC = 3
1903    // 0x07: STA #83            -> Mem[0x83] = 3

B00F    // 0x08: MOV AC, #15        -> AC = 15 (0x0F)
1904    // 0x09: STA #84            -> Mem[0x84] = 15

B007    // 0x0A: MOV AC, #7         -> AC = 7 (0x07)
1905    // 0x0B: STA #85            -> Mem[0x85] = 7

B008    // 0x0C: MOV AC, #8         -> AC = 8
1906    // 0x0D: STA #86            -> Mem[0x86] = 8

// ==========================================================================
// SECTION 2: Test ALU MEMORY operations (opcode 011101 - 100101)
// ==========================================================================

// --- Test ADD_M (opcode 011101 = 0x1D) ---
B00A    // 0x0E: MOV AC, #10        -> AC = 10
7480    // 0x0F: ADD_M #80          -> AC = AC + Mem[0x80] = 10 + 10 = 20
1907    // 0x10: STA #90            -> Mem[0x90] = 20

// --- Test SUB_M (opcode 011110 = 0x1E) ---
B014    // 0x11: MOV AC, #20        -> AC = 20
7881    // 0x12: SUB_M #81          -> AC = AC - Mem[0x81] = 20 - 5 = 15
1908    // 0x13: STA #91            -> Mem[0x91] = 15

// --- Test MUL_M (opcode 011111 = 0x1F) ---
B006    // 0x14: MOV AC, #6         -> AC = 6
7C81    // 0x15: MUL_M #81          -> AC = AC * Mem[0x81] = 6 * 5 = 30
1909    // 0x16: STA #92            -> Mem[0x92] = 30

// --- Test DIV_M (opcode 100000 = 0x20) ---
B014    // 0x17: MOV AC, #20        -> AC = 20
8083    // 0x18: DIV_M #83          -> AC = AC / Mem[0x83] = 20 / 3 = 6
190A    // 0x19: STA #93            -> Mem[0x93] = 6

// --- Test MOD_M (opcode 100001 = 0x21) ---
B014    // 0x1A: MOV AC, #20        -> AC = 20
8483    // 0x1B: MOD_M #83          -> AC = AC % Mem[0x83] = 20 % 3 = 2
190B    // 0x1C: STA #94            -> Mem[0x94] = 2

// --- Test AND_M (opcode 100010 = 0x22) ---
B00F    // 0x1D: MOV AC, #15        -> AC = 15 (0x0F)
8885    // 0x1E: AND_M #85          -> AC = AC & Mem[0x85] = 0x0F & 0x07 = 0x07
190C    // 0x1F: STA #95            -> Mem[0x95] = 7

// --- Test OR_M (opcode 100011 = 0x23) ---
B00F    // 0x20: MOV AC, #15        -> AC = 15 (0x0F)
8C85    // 0x21: OR_M #85           -> AC = AC | Mem[0x85] = 0x0F | 0x07 = 0x0F
190D    // 0x22: STA #96            -> Mem[0x96] = 15

// --- Test XOR_M (opcode 100100 = 0x24) ---
B008    // 0x23: MOV AC, #8         -> AC = 8 (0x08)
9085    // 0x24: XOR_M #85          -> AC = AC ^ Mem[0x85] = 0x08 ^ 0x07 = 0x0F
190E    // 0x25: STA #97            -> Mem[0x97] = 15

// --- Test NOT_M (opcode 100101 = 0x25) ---
9485    // 0x26: NOT_M #85          -> AC = ~Mem[0x85] = ~0x07 = 0xFFF8
190F    // 0x27: STA #98            -> Mem[0x98] = 0xFFF8

// ==========================================================================
// SECTION 3: Test CONTROL & MEMORY operations
// ==========================================================================

// --- Test LDA_IMM (opcode 000101) - Load AC from direct address ---
1480    // 0x28: LDA_IMM #80        -> AC = Mem[0x80] = 10
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test LDR (opcode 000001) - Load X/Y from address ---
0481    // 0x2A: LDR X, #81         -> X = Mem[0x81] = 5
1910    // 0x29: STA #99            -> Mem[0x99] = 10

0682    // 0x2C: LDR Y, #82         -> Y = Mem[0x82] = 20
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test LDA (opcode 000010) - Load AC with offset from X/Y ---
B042    // 0x2E: MOV X, #2          -> X = 2
0880    // 0x2F: LDA X, #80         -> AC = Mem[X + 0x80] = Mem[0x82] = 20
1910    // 0x29: STA #99            -> Mem[0x99] = 10

B081    // 0x31: MOV Y, #1          -> Y = 1
0A80    // 0x32: LDA Y, #80         -> AC = Mem[Y + 0x80] = Mem[0x81] = 5
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test STA (opcode 000100) - Store AC with offset to X/Y ---
B037    // 0x34: MOV AC, #55        -> AC = 55
B043    // 0x35: MOV X, #3          -> X = 3
1910    // 0x29: STA #99            -> Mem[0x99] = 10

B01E    // 0x37: MOV AC, #30        -> AC = 30
B082    // 0x38: MOV Y, #2          -> Y = 2
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// ==========================================================================
// SECTION 4: Test STACK operations (PSH/POP)
// ==========================================================================
// Selector: 0000-PC, 0001-AC, 0010-X, 0011-Y

// --- Test PSH AC (selector 0001) ---
B019    // 0x3A: MOV AC, #25        -> AC = 25
1C01    // 0x3B: PSH AC             -> Push AC to stack

// --- Test PSH X (selector 0010) ---
B068    // 0x3C: MOV X, #40         -> X = 40
1C02    // 0x3D: PSH X              -> Push X to stack

// --- Test PSH Y (selector 0011) ---
B0B2    // 0x3E: MOV Y, #50         -> Y = 50
1C03    // 0x3F: PSH Y              -> Push Y to stack

// --- Test POP Y (selector 0011) ---
2003    // 0x40: POP Y              -> Y = 50 (popped from stack)
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test POP X (selector 0010) ---
2002    // 0x42: POP X              -> X = 40 (popped from stack)
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test POP AC (selector 0001) ---
2001    // 0x44: POP AC             -> AC = 25 (popped from stack)
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// ==========================================================================
// SECTION 5: Test BRANCH operations
// ==========================================================================

// --- Test BEQ (Branch if Equal, Z=1) ---
B005    // 0x46: MOV AC, #5         -> AC = 5
B045    // 0x47: MOV X, #5          -> X = 5
A801    // 0x48: CMP AC, X          -> AC - X = 0, Z=1
2C4B    // 0x49: BEQ #4B            -> Z=1, branch taken
B03F    // 0x4A: MOV AC, #63        -> skip (not executed)
B001    // 0x4B: MOV AC, #1         -> AC = 1
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test BNE (Branch if Not Equal, Z=0) ---
B005    // 0x4D: MOV AC, #5         -> AC = 5
B046    // 0x4E: MOV X, #6          -> X = 6
A801    // 0x4F: CMP AC, X          -> AC - X != 0, Z=0
3052    // 0x50: BNE #52            -> Z=0, branch taken
B03F    // 0x51: MOV AC, #63        -> skip (not executed)
B002    // 0x52: MOV AC, #2         -> AC = 2
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test BGT (Branch if Greater, Z=0 && N==V) ---
B00A    // 0x54: MOV AC, #10        -> AC = 10
B045    // 0x55: MOV X, #5          -> X = 5
A801    // 0x56: CMP AC, X          -> AC - X = 5 > 0, Z=0, N=0, V=0
3459    // 0x57: BGT #59            -> Z=0 && N==V, branch taken
B03F    // 0x58: MOV AC, #63        -> skip (not executed)
B003    // 0x59: MOV AC, #3         -> AC = 3
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test BLT (Branch if Less, N!=V) ---
B005    // 0x5B: MOV AC, #5         -> AC = 5
B04A    // 0x5C: MOV X, #10         -> X = 10
A801    // 0x5D: CMP AC, X          -> AC - X = -5 < 0, N=1, V=0
3860    // 0x5E: BLT #60            -> N!=V, branch taken
B03F    // 0x5F: MOV AC, #63        -> skip (not executed)
B004    // 0x60: MOV AC, #4         -> AC = 4
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test BGE (Branch if Greater/Equal, N==V) ---
B00A    // 0x62: MOV AC, #10        -> AC = 10
B045    // 0x63: MOV X, #5          -> X = 5
A801    // 0x64: CMP AC, X          -> AC - X = 5 >= 0, N=0, V=0
3C67    // 0x65: BGE #67            -> N==V, branch taken
B03F    // 0x66: MOV AC, #63        -> skip (not executed)
B005    // 0x67: MOV AC, #5         -> AC = 5
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test BLE (Branch if Less/Equal, Z=1 || N!=V) ---
B005    // 0x69: MOV AC, #5         -> AC = 5
B045    // 0x6A: MOV X, #5          -> X = 5
A801    // 0x6B: CMP AC, X          -> AC - X = 0, Z=1
406E    // 0x6C: BLE #6E            -> Z=1, branch taken
B03F    // 0x6D: MOV AC, #63        -> skip (not executed)
B006    // 0x6E: MOV AC, #6         -> AC = 6
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test BRA (Branch Always) ---
4472    // 0x70: BRA #72            -> Always branch
4C00    // 0x71: RET                -> skip (not executed) Pop PC, return to 0x75
B007    // 0x72: MOV AC, #7         -> AC = 7
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test JMP (Jump = Push PC+1, then branch) and RET ---
4871    // 0x74: JMP #71            -> Push PC+1 (0x75), jump to 0x77
B03F    // 0x75: MOV AC, #63        -> skip (not executed)
B03F    // 0x76: MOV AC, #63        -> skip (not executed)
B008    // 0x77: MOV AC, #8         -> AC = 8
1910    // 0x29: STA #99            -> Mem[0x99] = 10
B03F    // 0x79: MOV AC, #63 
B009    // 0x7A: MOV AC, #9         -> AC = 9 (executed after RET)
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// ==========================================================================
// SECTION 6: Test ALU REG/IMM operations (ADD_R, SUB_R, etc.)
// ==========================================================================

// --- Test ADD_R with Reg (M=0) ---
B00A    // 0x7C: MOV AC, #10        -> AC = 10
B045    // 0x7D: MOV X, #5          -> X = 5
5000    // 0x7E: ADD AC, X          -> AC = AC + X = 10 + 5 = 15
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test ADD_R with Imm (M=1) ---
B00A    // 0x80: MOV AC, #10        -> AC = 10
5107    // 0x81: ADD AC, #7         -> AC = AC + 7 = 10 + 7 = 17
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test SUB_R with Reg (M=0) ---
B014    // 0x83: MOV AC, #20        -> AC = 20
B045    // 0x84: MOV X, #5          -> X = 5
5400    // 0x85: SUB AC, X          -> AC = AC - X = 20 - 5 = 15
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test SUB_R with Imm (M=1) ---
B014    // 0x87: MOV AC, #20        -> AC = 20
5503    // 0x88: SUB AC, #3         -> AC = AC - 3 = 20 - 3 = 17
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test MUL_R with Reg (M=0) ---
B006    // 0x8A: MOV AC, #6         -> AC = 6
B045    // 0x8B: MOV X, #5          -> X = 5
5800    // 0x8C: MUL AC, X          -> AC = AC * X = 6 * 5 = 30
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test MUL_R with Imm (M=1) ---
B006    // 0x8E: MOV AC, #6         -> AC = 6
5904    // 0x8F: MUL AC, #4         -> AC = AC * 4 = 6 * 4 = 24
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test DIV_R with Reg (M=0) ---
B014    // 0x91: MOV AC, #20        -> AC = 20
B043    // 0x92: MOV X, #3          -> X = 3
5C00    // 0x93: DIV AC, X          -> AC = AC / X = 20 / 3 = 6
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test DIV_R with Imm (M=1) ---
B014    // 0x95: MOV AC, #20        -> AC = 20
5D04    // 0x96: DIV AC, #4         -> AC = AC / 4 = 20 / 4 = 5
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test MOD_R with Reg (M=0) ---
B014    // 0x98: MOV AC, #20        -> AC = 20
B043    // 0x99: MOV X, #3          -> X = 3
6000    // 0x9A: MOD AC, X          -> AC = AC % X = 20 % 3 = 2
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test MOD_R with Imm (M=1) ---
B014    // 0x9C: MOV AC, #20        -> AC = 20
6104    // 0x9D: MOD AC, #4         -> AC = AC % 4 = 20 % 4 = 0
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test AND_R with Reg (M=0) ---
B00F    // 0x9F: MOV AC, #15        -> AC = 15 (0x0F)
B047    // 0xA0: MOV X, #7          -> X = 7 (0x07)
6400    // 0xA1: AND AC, X          -> AC = AC & X = 0x0F & 0x07 = 0x07
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test AND_R with Imm (M=1) ---
B00F    // 0xA3: MOV AC, #15        -> AC = 15 (0x0F)
6503    // 0xA4: AND AC, #3         -> AC = AC & 3 = 0x0F & 0x03 = 0x03
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test OR_R with Reg (M=0) ---
B008    // 0xA6: MOV AC, #8         -> AC = 8 (0x08)
B047    // 0xA7: MOV X, #7          -> X = 7 (0x07)
6800    // 0xA8: OR AC, X           -> AC = AC | X = 0x08 | 0x07 = 0x0F
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test OR_R with Imm (M=1) ---
B008    // 0xAA: MOV AC, #8         -> AC = 8 (0x08)
6907    // 0xAB: OR AC, #7          -> AC = AC | 7 = 0x08 | 0x07 = 0x0F
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test XOR_R with Reg (M=0) ---
B00F    // 0xAD: MOV AC, #15        -> AC = 15 (0x0F)
B047    // 0xAE: MOV X, #7          -> X = 7 (0x07)
6C00    // 0xAF: XOR AC, X          -> AC = AC ^ X = 0x0F ^ 0x07 = 0x08
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test XOR_R with Imm (M=1) ---
B00F    // 0xB1: MOV AC, #15        -> AC = 15 (0x0F)
6D0F    // 0xB2: XOR AC, #15        -> AC = AC ^ 15 = 0x0F ^ 0x0F = 0x00
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test NOT_R with Reg (M=0) ---
B047    // 0xB4: MOV X, #7          -> X = 7
7000    // 0xB5: NOT X              -> AC = ~X = ~0x07 = 0xFFF8
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test NOT_R with Imm (M=1) ---
710F    // 0xB7: NOT #15            -> AC = ~15 = ~0x0F = 0xFFF0
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// ==========================================================================
// SECTION 7: Test SHIFT operations
// ==========================================================================

// --- Test LSR (Logical Shift Right) ---
B010    // 0xB9: MOV AC, #16        -> AC = 16
9801    // 0xBA: LSR                -> AC = AC >> 1 = 16 >> 1 = 8
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test LSL (Logical Shift Left) ---
B008    // 0xBC: MOV AC, #8         -> AC = 8
9C02    // 0xBD: LSL                -> AC = AC << 1 = 8 << 1 = 16
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test RSR (Rotate Shift Right) ---
B001    // 0xBF: MOV AC, #1         -> AC = 1 (0x0001)
A001    // 0xC0: RSR                -> AC rotate right = 0x8000
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test RSL (Rotate Shift Left) ---
B020    // 0xC2: MOV AC, #32        -> AC = 32 (0x0020 = bit 5 set)
A401    // 0xC3: RSL                -> AC rotate left = 0x0040
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// ==========================================================================
// SECTION 8: Test CMP and TST
// ==========================================================================

// --- Test CMP (Compare) ---
B00A    // 0xC5: MOV AC, #10        -> AC = 10
B04A    // 0xC6: MOV X, #10         -> X = 10
A801    // 0xC7: CMP AC, X          -> AC - X = 0, Z=1
B001    // 0xC8: MOV AC, #1         -> AC = 1 (marker)
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test TST (Test) ---
B00F    // 0xCA: MOV AC, #15        -> AC = 15
B047    // 0xCB: MOV X, #7          -> X = 7
AC01    // 0xCC: TST AC, X          -> AC & X = 7, Z=0
B002    // 0xCD: MOV AC, #2         -> AC = 2 (marker)
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// ==========================================================================
// SECTION 9: Test MOVE operations
// ==========================================================================

// --- Test MOV Reg, #Imm (opcode 101100) ---
B01F    // 0xCF: MOV AC, #31        -> AC = 31
1910    // 0x29: STA #99            -> Mem[0x99] = 10

B07E    // 0xD1: MOV X, #62         -> X = 62
1910    // 0x29: STA #99            -> Mem[0x99] = 10

B0BD    // 0xD3: MOV Y, #61         -> Y = 61
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// --- Test MOV Reg, Reg (opcode 101101) ---
B015    // 0xD5: MOV AC, #21        -> AC = 21
B420    // 0xD6: MOV X, AC          -> X = AC = 21
1910    // 0x29: STA #99            -> Mem[0x99] = 10

B441    // 0xD8: MOV Y, X           -> Y = X = 21
1910    // 0x29: STA #99            -> Mem[0x99] = 10

B462    // 0xDA: MOV AC, Y          -> AC = Y = 21
1910    // 0x29: STA #99            -> Mem[0x99] = 10

// ==========================================================================
// SECTION 10: HLT
// ==========================================================================
0000    // 0xDC: HLT                -> Stop

// ==========================================================================
// DATA SECTION (0x80 - 0xCF)
// ==========================================================================
// Test data (0x80-0x8F)
0000    // 0x80: = 10 (initialized)
0000    // 0x81: = 5 (initialized)
0000    // 0x82: = 20 (initialized)
0000    // 0x83: = 3 (initialized)
0000    // 0x84: = 15 (initialized)
0000    // 0x85: = 7 (initialized)
0000    // 0x86: = 8 (initialized)
0000    // 0x87
0000    // 0x88
0000    // 0x89
0000    // 0x8A
0000    // 0x8B
0000    // 0x8C
0000    // 0x8D
0000    // 0x8E
0000    // 0x8F

// Test results (0x90-0xCF) - all initialized to 0x0000
0000    // 0x90: ADD_M result = 20
0000    // 0x91: SUB_M result = 15
0000    // 0x92: MUL_M result = 30
0000    // 0x93: DIV_M result = 6
0000    // 0x94: MOD_M result = 2
0000    // 0x95: AND_M result = 7
0000    // 0x96: OR_M result = 15
0000    // 0x97: XOR_M result = 15
0000    // 0x98: NOT_M result = 0xFFF8
0000    // 0x99: LDA_IMM result = 10
0000    // 0x9A: LDR X result = 5
0000    // 0x9B: LDR Y result = 20
0000    // 0x9C: LDA X result = 20
0000    // 0x9D: LDA Y result = 5
0000    // 0x9E: POP Y result = 50
0000    // 0x9F: POP X result = 40
0000    // 0xA0: POP AC result = 25
0000    // 0xA1: BEQ result = 1
0000    // 0xA2: BNE result = 2
0000    // 0xA3: BGT result = 3
0000    // 0xA4: BLT result = 4
0000    // 0xA5: BGE result = 5
0000    // 0xA6: BLE result = 6
0000    // 0xA7: BRA result = 7
0000    // 0xA8: JMP result = 8
0000    // 0xA9: RET result = 9
0000    // 0xAA: ADD_R Reg result = 15
0000    // 0xAB: ADD_R Imm result = 17
0000    // 0xAC: SUB_R Reg result = 15
0000    // 0xAD: SUB_R Imm result = 17
0000    // 0xAE: MUL_R Reg result = 30
0000    // 0xAF: MUL_R Imm result = 24
0000    // 0xB0: DIV_R Reg result = 6
0000    // 0xB1: DIV_R Imm result = 5
0000    // 0xB2: MOD_R Reg result = 2
0000    // 0xB3: MOD_R Imm result = 0
0000    // 0xB4: AND_R Reg result = 7
0000    // 0xB5: AND_R Imm result = 3
0000    // 0xB6: OR_R Reg result = 15
0000    // 0xB7: OR_R Imm result = 15
0000    // 0xB8: XOR_R Reg result = 8
0000    // 0xB9: XOR_R Imm result = 0
0000    // 0xBA: NOT_R Reg result = 0xFFF8
0000    // 0xBB: NOT_R Imm result = 0xFFF0
0000    // 0xBC: LSR result = 8
0000    // 0xBD: LSL result = 16
0000    // 0xBE: RSR result = 0x8000
0000    // 0xBF: RSL result = 0x0040
0000    // 0xC0: CMP result = 1
0000    // 0xC1: TST result = 2
0000    // 0xC2: MOV AC,#Imm result = 31
0000    // 0xC3: MOV X,#Imm result = 62
0000    // 0xC4: MOV Y,#Imm result = 61
0000    // 0xC5: MOV X,AC result = 21
0000    // 0xC6: MOV Y,X result = 21
0000    // 0xC7: MOV AC,Y result = 21
0000    // 0xC8
0000    // 0xC9
0000    // 0xCA
0000    // 0xCB
0000    // 0xCC
0000    // 0xCD
0000    // 0xCE
0000    // 0xCF

/// 7
// =========================================================================
// BUBBLE SORT - Adaptat pentru AC, X, Y
// =========================================================================
// Mem[0x100]=N, Mem[0x101]=i, Mem[0x102]=j, Mem[0x103]=temp
// Array la 0xC8 (200 decimal)
// =========================================================================

// === MAIN (0x00-0x03) ===
4810    // 0x00: JMP 0x10               ; call readEl
4830    // 0x01: JMP 0x30               ; call bbsort
4870    // 0x02: JMP 0x70               ; call printArray
0000    // 0x03: HLT

// === PADDING (0x04-0x0F) ===
0000    // 0x04
0000    // 0x05
0000    // 0x06
0000    // 0x07
0000    // 0x08
0000    // 0x09
0000    // 0x0A
0000    // 0x0B
0000    // 0x0C
0000    // 0x0D
0000    // 0x0E
0000    // 0x0F

// === readEl (0x10-0x1F) ===
2401    // 0x10: IN AC                  ; Read N
1900    // 0x11: STA_IMM 0x100          ; Mem[0x100] = N
B000    // 0x12: MOV AC, #0             ; i = 0
B420    // 0x13: MOV X, AC              ; X = i
2401    // 0x14: IN AC                  ; Read arr[i]
10C8    // 0x15: STA X, 0xC8            ; Mem[0xC8 + X] = AC
B401    // 0x16: MOV AC, X              ; AC = X
5101    // 0x17: ADD AC, #1             ; AC++
B420    // 0x18: MOV X, AC              ; X = AC
B440    // 0x19: MOV Y, AC              ; Y = AC
1500    // 0x1A: LDA_IMM 0x100          ; AC = N
A802    // 0x1B: CMP AC, Y              ; Compare N with i
3414    // 0x1C: BGT 0x14               ; if N > i, loop
4C00    // 0x1D: RET                    ; return
0000    // 0x1E
0000    // 0x1F

// === PADDING (0x20-0x2F) ===
0000    // 0x20
0000    // 0x21
0000    // 0x22
0000    // 0x23
0000    // 0x24
0000    // 0x25
0000    // 0x26
0000    // 0x27
0000    // 0x28
0000    // 0x29
0000    // 0x2A
0000    // 0x2B
0000    // 0x2C
0000    // 0x2D
0000    // 0x2E
0000    // 0x2F

// === bbsort (0x30-0x6F) ===
B000    // 0x30: MOV AC, #0             ; i = 0
1901    // 0x31: STA_IMM 0x101          ; Mem[0x101] = i

// outer_loop (0x32):
1501    // 0x32: LDA_IMM 0x101          ; AC = i
B420    // 0x33: MOV X, AC              ; X = i
1500    // 0x34: LDA_IMM 0x100          ; AC = N
5501    // 0x35: SUB AC, #1             ; AC = N - 1
A801    // 0x36: CMP AC, X              ; Compare (N-1) with i
3439    // 0x37: BGT 0x39               ; if (N-1) > i, continue
4C00    // 0x38: RET                    ; else return

// inner_init (0x39):
B000    // 0x39: MOV AC, #0             ; j = 0
1902    // 0x3A: STA_IMM 0x102          ; Mem[0x102] = j

// inner_loop (0x3B):
1502    // 0x3B: LDA_IMM 0x102          ; AC = j
B420    // 0x3C: MOV X, AC              ; X = j
1500    // 0x3D: LDA_IMM 0x100          ; AC = N
5501    // 0x3E: SUB AC, #1             ; AC = N - 1
1501    // 0x3F: LDA_IMM 0x101          ; AC = i
B440    // 0x40: MOV Y, AC              ; Y = i
1500    // 0x41: LDA_IMM 0x100          ; AC = N
5501    // 0x42: SUB AC, #1             ; AC = N - 1
5402    // 0x43: SUB AC, Y              ; AC = N - 1 - i
A801    // 0x44: CMP AC, X              ; Compare (N-1-i) with j
3448    // 0x45: BGT 0x48               ; if (N-1-i) > j, continue
4466    // 0x46: BRA 0x66               ; else goto outer_inc
0000    // 0x47

// compare (0x48):
1502    // 0x48: LDA_IMM 0x102          ; AC = j
B420    // 0x49: MOV X, AC              ; X = j
08C8    // 0x4A: LDA X, 0xC8            ; AC = arr[j]
B440    // 0x4B: MOV Y, AC              ; Y = arr[j]
1502    // 0x4C: LDA_IMM 0x102          ; AC = j
5101    // 0x4D: ADD AC, #1             ; AC = j + 1
B420    // 0x4E: MOV X, AC              ; X = j + 1
08C8    // 0x4F: LDA X, 0xC8            ; AC = arr[j+1]

A802    // 0x50: CMP AC, Y              ; Compare arr[j+1] with arr[j]
3C5F    // 0x51: BGE 0x5F               ; if arr[j+1] >= arr[j], skip swap

// swap (0x52):
1903    // 0x52: STA_IMM 0x103          ; temp = arr[j+1]
B402    // 0x53: MOV AC, Y              ; AC = arr[j]
1502    // 0x54: LDA_IMM 0x102          ; AC = j
5101    // 0x55: ADD AC, #1             ; AC = j + 1
B420    // 0x56: MOV X, AC              ; X = j + 1
B402    // 0x57: MOV AC, Y              ; AC = arr[j]
10C8    // 0x58: STA X, 0xC8            ; arr[j+1] = arr[j]
1502    // 0x59: LDA_IMM 0x102          ; AC = j
B420    // 0x5A: MOV X, AC              ; X = j
1503    // 0x5B: LDA_IMM 0x103          ; AC = temp
10C8    // 0x5C: STA X, 0xC8            ; arr[j] = temp
0000    // 0x5D
0000    // 0x5E

// inner_inc (0x5F):
1502    // 0x5F: LDA_IMM 0x102          ; AC = j
5101    // 0x60: ADD AC, #1             ; AC = j + 1
1902    // 0x61: STA_IMM 0x102          ; j++
443B    // 0x62: BRA 0x3B               ; goto inner_loop
0000    // 0x63
0000    // 0x64
0000    // 0x65

// outer_inc (0x66):
1501    // 0x66: LDA_IMM 0x101          ; AC = i
5101    // 0x67: ADD AC, #1             ; AC = i + 1
1901    // 0x68: STA_IMM 0x101          ; i++
4432    // 0x69: BRA 0x32               ; goto outer_loop
0000    // 0x6A
0000    // 0x6B
0000    // 0x6C
0000    // 0x6D
0000    // 0x6E
0000    // 0x6F

// === printArray (0x70-0x7F) ===
B000    // 0x70: MOV AC, #0             ; i = 0
B420    // 0x71: MOV X, AC              ; X = i

// print_loop (0x72):
B401    // 0x72: MOV AC, X              ; AC = X
B440    // 0x73: MOV Y, AC              ; Y = X
1500    // 0x74: LDA_IMM 0x100          ; AC = N
A802    // 0x75: CMP AC, Y              ; Compare N with i
3479    // 0x76: BGT 0x79               ; if N > i, continue
4C00    // 0x77: RET                    ; else return
0000    // 0x78

// print_elem (0x79):
08C8    // 0x79: LDA X, 0xC8            ; AC = arr[i]
2801    // 0x7A: OUT AC                 ; Output arr[i]
B401    // 0x7B: MOV AC, X              ; AC = X
5101    // 0x7C: ADD AC, #1             ; AC++
B420    // 0x7D: MOV X, AC              ; X = AC
4472    // 0x7E: BRA 0x72               ; goto print_loop
0000    // 0x7F

// === PADDING to 0xC7 ===
0000    // 0x80
0000    // 0x81
0000    // 0x82
0000    // 0x83
0000    // 0x84
0000    // 0x85
0000    // 0x86
0000    // 0x87
0000    // 0x88
0000    // 0x89
0000    // 0x8A
0000    // 0x8B
0000    // 0x8C
0000    // 0x8D
0000    // 0x8E
0000    // 0x8F
0000    // 0x90
0000    // 0x91
0000    // 0x92
0000    // 0x93
0000    // 0x94
0000    // 0x95
0000    // 0x96
0000    // 0x97
0000    // 0x98
0000    // 0x99
0000    // 0x9A
0000    // 0x9B
0000    // 0x9C
0000    // 0x9D
0000    // 0x9E
0000    // 0x9F
0000    // 0xA0
0000    // 0xA1
0000    // 0xA2
0000    // 0xA3
0000    // 0xA4
0000    // 0xA5
0000    // 0xA6
0000    // 0xA7
0000    // 0xA8
0000    // 0xA9
0000    // 0xAA
0000    // 0xAB
0000    // 0xAC
0000    // 0xAD
0000    // 0xAE
0000    // 0xAF
0000    // 0xB0
0000    // 0xB1
0000    // 0xB2
0000    // 0xB3
0000    // 0xB4
0000    // 0xB5
0000    // 0xB6
0000    // 0xB7
0000    // 0xB8
0000    // 0xB9
0000    // 0xBA
0000    // 0xBB
0000    // 0xBC
0000    // 0xBD
0000    // 0xBE
0000    // 0xBF
0000    // 0xC0
0000    // 0xC1
0000    // 0xC2
0000    // 0xC3
0000    // 0xC4
0000    // 0xC5
0000    // 0xC6
0000    // 0xC7

// === ARRAY at 0xC8 (200 decimal) ===
0000    // 0xC8: arr[0]
0000    // 0xC9: arr[1]
0000    // 0xCA: arr[2]
0000    // 0xCB: arr[3]
0000    // 0xCC: arr[4]
0000    // 0xCD: arr[5]
0000    // 0xCE: arr[6]
0000    // 0xCF: arr[7]
0000    // 0xD0: arr[8]
0000    // 0xD1: arr[9]
0000    // 0xD2: arr[10]
0000    // 0xD3: arr[11]
0000    // 0xD4: arr[12]
0000    // 0xD5: arr[13]
0000    // 0xD6: arr[14]
0000    // 0xD7: arr[15]
0000    // 0xD8
0000    // 0xD9
0000    // 0xDA
0000    // 0xDB
0000    // 0xDC
0000    // 0xDD
0000    // 0xDE
0000    // 0xDF
0000    // 0xE0
0000    // 0xE1
0000    // 0xE2
0000    // 0xE3
0000    // 0xE4
0000    // 0xE5
0000    // 0xE6
0000    // 0xE7
0000    // 0xE8
0000    // 0xE9
0000    // 0xEA
0000    // 0xEB
0000    // 0xEC
0000    // 0xED
0000    // 0xEE
0000    // 0xEF
0000    // 0xF0
0000    // 0xF1
0000    // 0xF2
0000    // 0xF3
0000    // 0xF4
0000    // 0xF5
0000    // 0xF6
0000    // 0xF7
0000    // 0xF8
0000    // 0xF9
0000    // 0xFA
0000    // 0xFB
0000    // 0xFC
0000    // 0xFD
0000    // 0xFE
0000    // 0xFF

// === VARIABLES at 0x100 ===
0000    // 0x100: N
0000    // 0x101: i
0000    // 0x102: j
0000    // 0x103: temp
